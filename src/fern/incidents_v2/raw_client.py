# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.custom_field_entry_payload_v2 import CustomFieldEntryPayloadV2
from ..types.incident_edit_payload_v2 import IncidentEditPayloadV2
from ..types.incident_role_assignment_payload_v2 import IncidentRoleAssignmentPayloadV2
from ..types.incident_timestamp_value_payload_v2 import IncidentTimestampValuePayloadV2
from ..types.incidents_create_result_v2 import IncidentsCreateResultV2
from ..types.incidents_edit_result_v2 import IncidentsEditResultV2
from ..types.incidents_list_result_v2 import IncidentsListResultV2
from ..types.incidents_show_result_v2 import IncidentsShowResultV2
from ..types.retrospective_incident_options_v2 import RetrospectiveIncidentOptionsV2
from .types.incidents_create_payload_v2mode import IncidentsCreatePayloadV2Mode
from .types.incidents_create_payload_v2visibility import IncidentsCreatePayloadV2Visibility
from .types.incidents_v2list_request_filter_mode import IncidentsV2ListRequestFilterMode

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawIncidentsV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        filter_mode: typing.Optional[IncidentsV2ListRequestFilterMode] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status_category: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        updated_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        severity: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        incident_type: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        incident_role: typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]] = None,
        custom_field: typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]] = None,
        mode: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IncidentsListResultV2]:
        """
        List all incidents for an organisation.
        
        This endpoint supports a number of filters, which can help find incidents matching certain
        criteria.
        
        Filters are provided as query parameters, but due to the dynamic nature of what you can
        query by (different accounts have different custom fields, statuses, etc) they are more
        complex than most.
        
        The maximum page size that can be requested is 250.
        
        To help, here are some exemplar curl requests with a human description of what they search
        for.
        
        Note that:
        - Filters may be combined using the filter_mode parameter: 'all' (default) requires all filters
        to match (AND logic), while 'any' requires at least one filter to match (OR logic).
        - IDs are normally in UUID format, but have been replaced with shorter strings to improve
        readability.
        - All query parameters must be URI encoded.
        
        ### By status
        
        With status of id=ABC, find all incidents that are set to that status:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status[one_of]=ABC'
        
        Or all incidents that are not set to status with id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status[not_in]=ABC'
        
        ### By created_at or updated_at
        
        Find all incidents that follow specified date parameters for created_at and updated_at fields.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
        "date_range" (between two dates). The following example finds all incidents created before
        or on 2021-01-02T00:00:00Z:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'created_at[lte]=2021-01-02'
        
        To find incidents created within a specific date range, use the date_range option with
        tilde-separated dates:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'created_at[date_range]=2024-12-02~2024-12-08'
        
        ### By status category
        
        Find all incidents that are in a status category. Possible values are "triage",
        "declined", "merged", "canceled", "live", "learning" and "closed":
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status_category[one_of]=live'
        
        Or all incidents that are not in a status category:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status_category[not_in]=live'
        
        
        ### By severity
        
        With severity of id=ABC, find all incidents that are set to that severity:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[one_of]=ABC'
        
        Or all incidents where severity rank is greater-than-or-equal-to the rank of severity
        id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[gte]=ABC'
        
        Or all incidents where severity rank is less-than-or-equal-to the rank of severity id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[lte]=ABC'
        
        ### By incident type
        
        With incident type of id=ABC, find all incidents that are of that type:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_type[one_of]=ABC'
        
        Or all incidents not of that type:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_type[not_in]=ABC'
        
        ### By incident mode
        
        By default, we return standard and retrospective incidents. This means that test and
        tutorial incidents are filtered out. To override this behaviour, you can use the
        mode filter to specify which modes you want to get.
        
        To find incidents of all modes:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'mode[one_of]=standard&mode[one_of]=retrospective&mode[one_of]=test&mode[one_of]=tutorial'
        
        To find just test incidents:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'mode[one_of]=test'
        
        
        ### By incident role
        
        Roles and custom fields have another nested layer in the query parameter, to account for
        operations against any of the roles or custom fields created in the account.
        
        With incident role id=ABC, find all incidents where that role is unset:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_role[ABC][is_set]=true'
        
        Or where the role has been set:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_role[ABC][is_set]=false'
        
        ### By option custom fields
        
        With an option custom field id=ABC, all incidents that have field ABC set to the custom
        field option of id=XYZ:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents' \\
                    --data 'custom_field[ABC][one_of]=XYZ'
        
        Or all incidents that do not have custom field id=ABC set to option id=XYZ:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents' \\
                    --data 'custom_field[ABC][not_in]=XYZ'
        
        Parameters
        ----------
        page_size : typing.Optional[int]
            Integer number of records to return
        
        after : typing.Optional[str]
            An incident's ID. This endpoint will return a list of incidents after this ID in relation to the API response order.
        
        filter_mode : typing.Optional[IncidentsV2ListRequestFilterMode]
            How to combine the filters: 'all' combines them with AND logic (all must match), 'any' combines them with OR logic (any can match). Defaults to 'all'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident status. The accepted operators are 'one_of', or 'not_in'.
        
        status_category : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the category of the incidents status. The accepted operators are 'one_of', or 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident created at timestamp. The accepted operators are 'gte', 'lte' and 'date_range'.
        
        updated_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident updated at timestamp. The accepted operators are 'gte', 'lte' and 'date_range'.
        
        severity : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident severity. The accepted operators are 'one_of', 'not_in', 'gte', 'lte'.
        
        incident_type : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident type. The accepted operators are 'one_of, or 'not_in'.
        
        incident_role : typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]]
            Filter on an incident role. Role ID should be sent, followed by the operator and values. The accepted operators are 'one_of', 'is_blank'.
        
        custom_field : typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]]
            Filter on an incident custom field. Custom field ID should be sent, followed by the operator and values. Accepted operator will depend on the custom field type.
        
        mode : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident mode. The accepted operator is 'one_of'.  If this is not provided, this value defaults to `{"one_of": ["standard", "retrospective"] }`, meaning that test and tutorial incidents are not included.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[IncidentsListResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/incidents",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "filter_mode": filter_mode,
                "status": status,
                "status_category": status_category,
                "created_at": created_at,
                "updated_at": updated_at,
                "severity": severity,
                "incident_type": incident_type,
                "incident_role": incident_role,
                "custom_field": custom_field,
                "mode": mode,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsListResultV2,
                    parse_obj_as(
                        type_=IncidentsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        visibility: IncidentsCreatePayloadV2Visibility,
        custom_field_entries: typing.Optional[typing.Sequence[CustomFieldEntryPayloadV2]] = OMIT,
        incident_role_assignments: typing.Optional[typing.Sequence[IncidentRoleAssignmentPayloadV2]] = OMIT,
        incident_status_id: typing.Optional[str] = OMIT,
        incident_timestamp_values: typing.Optional[typing.Sequence[IncidentTimestampValuePayloadV2]] = OMIT,
        incident_type_id: typing.Optional[str] = OMIT,
        mode: typing.Optional[IncidentsCreatePayloadV2Mode] = OMIT,
        name: typing.Optional[str] = OMIT,
        retrospective_incident_options: typing.Optional[RetrospectiveIncidentOptionsV2] = OMIT,
        severity_id: typing.Optional[str] = OMIT,
        slack_channel_name_override: typing.Optional[str] = OMIT,
        slack_team_id: typing.Optional[str] = OMIT,
        summary: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IncidentsCreateResultV2]:
        """
        Create a new incident.

        Note that if the incident mode is set to "retrospective" then the new incident
        will not be announced in Slack.

        Parameters
        ----------
        idempotency_key : str
            Unique string used to de-duplicate incident create requests

        visibility : IncidentsCreatePayloadV2Visibility
            Whether the incident should be open to anyone in your Slack workspace (public), or invite-only (private). For more information on Private Incidents see our [help centre](https://help.incident.io/articles/5905558102-can-we-mark-incidents-as-sensitive-and-restrict-access).

        custom_field_entries : typing.Optional[typing.Sequence[CustomFieldEntryPayloadV2]]
            Set the incident's custom fields to these values

        incident_role_assignments : typing.Optional[typing.Sequence[IncidentRoleAssignmentPayloadV2]]
            Assign incident roles to these people

        incident_status_id : typing.Optional[str]
            Incident status to assign to the incident

        incident_timestamp_values : typing.Optional[typing.Sequence[IncidentTimestampValuePayloadV2]]
            Assign the incident's timestamps to these values

        incident_type_id : typing.Optional[str]
            Incident type to create this incident as

        mode : typing.Optional[IncidentsCreatePayloadV2Mode]
            Whether the incident is real, a test, a tutorial, or importing as a retrospective incident

        name : typing.Optional[str]
            Explanation of the incident

        retrospective_incident_options : typing.Optional[RetrospectiveIncidentOptionsV2]

        severity_id : typing.Optional[str]
            Severity to create incident as

        slack_channel_name_override : typing.Optional[str]
            Name of the Slack channel to create for this incident

        slack_team_id : typing.Optional[str]
            Slack Team to create the incident in

        summary : typing.Optional[str]
            Detailed description of the incident

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IncidentsCreateResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/incidents",
            method="POST",
            json={
                "custom_field_entries": convert_and_respect_annotation_metadata(
                    object_=custom_field_entries,
                    annotation=typing.Sequence[CustomFieldEntryPayloadV2],
                    direction="write",
                ),
                "idempotency_key": idempotency_key,
                "incident_role_assignments": convert_and_respect_annotation_metadata(
                    object_=incident_role_assignments,
                    annotation=typing.Sequence[IncidentRoleAssignmentPayloadV2],
                    direction="write",
                ),
                "incident_status_id": incident_status_id,
                "incident_timestamp_values": convert_and_respect_annotation_metadata(
                    object_=incident_timestamp_values,
                    annotation=typing.Sequence[IncidentTimestampValuePayloadV2],
                    direction="write",
                ),
                "incident_type_id": incident_type_id,
                "mode": mode,
                "name": name,
                "retrospective_incident_options": convert_and_respect_annotation_metadata(
                    object_=retrospective_incident_options, annotation=RetrospectiveIncidentOptionsV2, direction="write"
                ),
                "severity_id": severity_id,
                "slack_channel_name_override": slack_channel_name_override,
                "slack_team_id": slack_team_id,
                "summary": summary,
                "visibility": visibility,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsCreateResultV2,
                    parse_obj_as(
                        type_=IncidentsCreateResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[IncidentsShowResultV2]:
        """
        Get a single incident.
        
        The ID supplied can be either the incident's full ID, or the numeric part of its
        reference. For example, to get INC-123, you could use either its full ID or:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents/123
        
        Parameters
        ----------
        id : str
            Unique identifier for the incident
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[IncidentsShowResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/incidents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsShowResultV2,
                    parse_obj_as(
                        type_=IncidentsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit(
        self,
        id: str,
        *,
        incident: IncidentEditPayloadV2,
        notify_incident_channel: bool,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IncidentsEditResultV2]:
        """
        Edit an existing incident.

        This endpoint allows you to edit the properties of an existing incident: e.g. set the severity or update custom fields.

        When using this endpoint, only fields that are provided will be edited (omitted fields
        will be ignored).

        Parameters
        ----------
        id : str
            The unique identifier of the incident that you want to edit

        incident : IncidentEditPayloadV2

        notify_incident_channel : bool
            Should we send Slack channel notifications to inform responders of this update? Note that this won't work if the Slack channel has already been archived.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IncidentsEditResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/incidents/{jsonable_encoder(id)}/actions/edit",
            method="POST",
            json={
                "incident": convert_and_respect_annotation_metadata(
                    object_=incident, annotation=IncidentEditPayloadV2, direction="write"
                ),
                "notify_incident_channel": notify_incident_channel,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsEditResultV2,
                    parse_obj_as(
                        type_=IncidentsEditResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawIncidentsV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        filter_mode: typing.Optional[IncidentsV2ListRequestFilterMode] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status_category: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        updated_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        severity: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        incident_type: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        incident_role: typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]] = None,
        custom_field: typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]] = None,
        mode: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IncidentsListResultV2]:
        """
        List all incidents for an organisation.
        
        This endpoint supports a number of filters, which can help find incidents matching certain
        criteria.
        
        Filters are provided as query parameters, but due to the dynamic nature of what you can
        query by (different accounts have different custom fields, statuses, etc) they are more
        complex than most.
        
        The maximum page size that can be requested is 250.
        
        To help, here are some exemplar curl requests with a human description of what they search
        for.
        
        Note that:
        - Filters may be combined using the filter_mode parameter: 'all' (default) requires all filters
        to match (AND logic), while 'any' requires at least one filter to match (OR logic).
        - IDs are normally in UUID format, but have been replaced with shorter strings to improve
        readability.
        - All query parameters must be URI encoded.
        
        ### By status
        
        With status of id=ABC, find all incidents that are set to that status:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status[one_of]=ABC'
        
        Or all incidents that are not set to status with id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status[not_in]=ABC'
        
        ### By created_at or updated_at
        
        Find all incidents that follow specified date parameters for created_at and updated_at fields.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
        "date_range" (between two dates). The following example finds all incidents created before
        or on 2021-01-02T00:00:00Z:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'created_at[lte]=2021-01-02'
        
        To find incidents created within a specific date range, use the date_range option with
        tilde-separated dates:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'created_at[date_range]=2024-12-02~2024-12-08'
        
        ### By status category
        
        Find all incidents that are in a status category. Possible values are "triage",
        "declined", "merged", "canceled", "live", "learning" and "closed":
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status_category[one_of]=live'
        
        Or all incidents that are not in a status category:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'status_category[not_in]=live'
        
        
        ### By severity
        
        With severity of id=ABC, find all incidents that are set to that severity:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[one_of]=ABC'
        
        Or all incidents where severity rank is greater-than-or-equal-to the rank of severity
        id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[gte]=ABC'
        
        Or all incidents where severity rank is less-than-or-equal-to the rank of severity id=ABC:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'severity[lte]=ABC'
        
        ### By incident type
        
        With incident type of id=ABC, find all incidents that are of that type:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_type[one_of]=ABC'
        
        Or all incidents not of that type:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_type[not_in]=ABC'
        
        ### By incident mode
        
        By default, we return standard and retrospective incidents. This means that test and
        tutorial incidents are filtered out. To override this behaviour, you can use the
        mode filter to specify which modes you want to get.
        
        To find incidents of all modes:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'mode[one_of]=standard&mode[one_of]=retrospective&mode[one_of]=test&mode[one_of]=tutorial'
        
        To find just test incidents:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'mode[one_of]=test'
        
        
        ### By incident role
        
        Roles and custom fields have another nested layer in the query parameter, to account for
        operations against any of the roles or custom fields created in the account.
        
        With incident role id=ABC, find all incidents where that role is unset:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_role[ABC][is_set]=true'
        
        Or where the role has been set:
        
                curl --get 'https://api.incident.io/v2/incidents' \\
                    --data 'incident_role[ABC][is_set]=false'
        
        ### By option custom fields
        
        With an option custom field id=ABC, all incidents that have field ABC set to the custom
        field option of id=XYZ:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents' \\
                    --data 'custom_field[ABC][one_of]=XYZ'
        
        Or all incidents that do not have custom field id=ABC set to option id=XYZ:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents' \\
                    --data 'custom_field[ABC][not_in]=XYZ'
        
        Parameters
        ----------
        page_size : typing.Optional[int]
            Integer number of records to return
        
        after : typing.Optional[str]
            An incident's ID. This endpoint will return a list of incidents after this ID in relation to the API response order.
        
        filter_mode : typing.Optional[IncidentsV2ListRequestFilterMode]
            How to combine the filters: 'all' combines them with AND logic (all must match), 'any' combines them with OR logic (any can match). Defaults to 'all'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident status. The accepted operators are 'one_of', or 'not_in'.
        
        status_category : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the category of the incidents status. The accepted operators are 'one_of', or 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident created at timestamp. The accepted operators are 'gte', 'lte' and 'date_range'.
        
        updated_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident updated at timestamp. The accepted operators are 'gte', 'lte' and 'date_range'.
        
        severity : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident severity. The accepted operators are 'one_of', 'not_in', 'gte', 'lte'.
        
        incident_type : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident type. The accepted operators are 'one_of, or 'not_in'.
        
        incident_role : typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]]
            Filter on an incident role. Role ID should be sent, followed by the operator and values. The accepted operators are 'one_of', 'is_blank'.
        
        custom_field : typing.Optional[typing.Dict[str, typing.Dict[str, typing.Sequence[str]]]]
            Filter on an incident custom field. Custom field ID should be sent, followed by the operator and values. Accepted operator will depend on the custom field type.
        
        mode : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on incident mode. The accepted operator is 'one_of'.  If this is not provided, this value defaults to `{"one_of": ["standard", "retrospective"] }`, meaning that test and tutorial incidents are not included.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[IncidentsListResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/incidents",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "filter_mode": filter_mode,
                "status": status,
                "status_category": status_category,
                "created_at": created_at,
                "updated_at": updated_at,
                "severity": severity,
                "incident_type": incident_type,
                "incident_role": incident_role,
                "custom_field": custom_field,
                "mode": mode,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsListResultV2,
                    parse_obj_as(
                        type_=IncidentsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        visibility: IncidentsCreatePayloadV2Visibility,
        custom_field_entries: typing.Optional[typing.Sequence[CustomFieldEntryPayloadV2]] = OMIT,
        incident_role_assignments: typing.Optional[typing.Sequence[IncidentRoleAssignmentPayloadV2]] = OMIT,
        incident_status_id: typing.Optional[str] = OMIT,
        incident_timestamp_values: typing.Optional[typing.Sequence[IncidentTimestampValuePayloadV2]] = OMIT,
        incident_type_id: typing.Optional[str] = OMIT,
        mode: typing.Optional[IncidentsCreatePayloadV2Mode] = OMIT,
        name: typing.Optional[str] = OMIT,
        retrospective_incident_options: typing.Optional[RetrospectiveIncidentOptionsV2] = OMIT,
        severity_id: typing.Optional[str] = OMIT,
        slack_channel_name_override: typing.Optional[str] = OMIT,
        slack_team_id: typing.Optional[str] = OMIT,
        summary: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IncidentsCreateResultV2]:
        """
        Create a new incident.

        Note that if the incident mode is set to "retrospective" then the new incident
        will not be announced in Slack.

        Parameters
        ----------
        idempotency_key : str
            Unique string used to de-duplicate incident create requests

        visibility : IncidentsCreatePayloadV2Visibility
            Whether the incident should be open to anyone in your Slack workspace (public), or invite-only (private). For more information on Private Incidents see our [help centre](https://help.incident.io/articles/5905558102-can-we-mark-incidents-as-sensitive-and-restrict-access).

        custom_field_entries : typing.Optional[typing.Sequence[CustomFieldEntryPayloadV2]]
            Set the incident's custom fields to these values

        incident_role_assignments : typing.Optional[typing.Sequence[IncidentRoleAssignmentPayloadV2]]
            Assign incident roles to these people

        incident_status_id : typing.Optional[str]
            Incident status to assign to the incident

        incident_timestamp_values : typing.Optional[typing.Sequence[IncidentTimestampValuePayloadV2]]
            Assign the incident's timestamps to these values

        incident_type_id : typing.Optional[str]
            Incident type to create this incident as

        mode : typing.Optional[IncidentsCreatePayloadV2Mode]
            Whether the incident is real, a test, a tutorial, or importing as a retrospective incident

        name : typing.Optional[str]
            Explanation of the incident

        retrospective_incident_options : typing.Optional[RetrospectiveIncidentOptionsV2]

        severity_id : typing.Optional[str]
            Severity to create incident as

        slack_channel_name_override : typing.Optional[str]
            Name of the Slack channel to create for this incident

        slack_team_id : typing.Optional[str]
            Slack Team to create the incident in

        summary : typing.Optional[str]
            Detailed description of the incident

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IncidentsCreateResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/incidents",
            method="POST",
            json={
                "custom_field_entries": convert_and_respect_annotation_metadata(
                    object_=custom_field_entries,
                    annotation=typing.Sequence[CustomFieldEntryPayloadV2],
                    direction="write",
                ),
                "idempotency_key": idempotency_key,
                "incident_role_assignments": convert_and_respect_annotation_metadata(
                    object_=incident_role_assignments,
                    annotation=typing.Sequence[IncidentRoleAssignmentPayloadV2],
                    direction="write",
                ),
                "incident_status_id": incident_status_id,
                "incident_timestamp_values": convert_and_respect_annotation_metadata(
                    object_=incident_timestamp_values,
                    annotation=typing.Sequence[IncidentTimestampValuePayloadV2],
                    direction="write",
                ),
                "incident_type_id": incident_type_id,
                "mode": mode,
                "name": name,
                "retrospective_incident_options": convert_and_respect_annotation_metadata(
                    object_=retrospective_incident_options, annotation=RetrospectiveIncidentOptionsV2, direction="write"
                ),
                "severity_id": severity_id,
                "slack_channel_name_override": slack_channel_name_override,
                "slack_team_id": slack_team_id,
                "summary": summary,
                "visibility": visibility,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsCreateResultV2,
                    parse_obj_as(
                        type_=IncidentsCreateResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[IncidentsShowResultV2]:
        """
        Get a single incident.
        
        The ID supplied can be either the incident's full ID, or the numeric part of its
        reference. For example, to get INC-123, you could use either its full ID or:
        
                curl \\
                    --get 'https://api.incident.io/v2/incidents/123
        
        Parameters
        ----------
        id : str
            Unique identifier for the incident
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[IncidentsShowResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/incidents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsShowResultV2,
                    parse_obj_as(
                        type_=IncidentsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit(
        self,
        id: str,
        *,
        incident: IncidentEditPayloadV2,
        notify_incident_channel: bool,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IncidentsEditResultV2]:
        """
        Edit an existing incident.

        This endpoint allows you to edit the properties of an existing incident: e.g. set the severity or update custom fields.

        When using this endpoint, only fields that are provided will be edited (omitted fields
        will be ignored).

        Parameters
        ----------
        id : str
            The unique identifier of the incident that you want to edit

        incident : IncidentEditPayloadV2

        notify_incident_channel : bool
            Should we send Slack channel notifications to inform responders of this update? Note that this won't work if the Slack channel has already been archived.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IncidentsEditResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/incidents/{jsonable_encoder(id)}/actions/edit",
            method="POST",
            json={
                "incident": convert_and_respect_annotation_metadata(
                    object_=incident, annotation=IncidentEditPayloadV2, direction="write"
                ),
                "notify_incident_channel": notify_incident_channel,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IncidentsEditResultV2,
                    parse_obj_as(
                        type_=IncidentsEditResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

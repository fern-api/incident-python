# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.escalation_path_node_payload_v2 import EscalationPathNodePayloadV2
from ..types.escalations_create_path_result_v2 import EscalationsCreatePathResultV2
from ..types.escalations_create_result_v2 import EscalationsCreateResultV2
from ..types.escalations_list_result_v2 import EscalationsListResultV2
from ..types.escalations_show_path_result_v2 import EscalationsShowPathResultV2
from ..types.escalations_show_result_v2 import EscalationsShowResultV2
from ..types.escalations_update_path_result_v2 import EscalationsUpdatePathResultV2
from ..types.weekday_interval_config_v2 import WeekdayIntervalConfigV2

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEscalationsV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def createpath(
        self,
        *,
        name: str,
        path: typing.Sequence[EscalationPathNodePayloadV2],
        team_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        working_hours: typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EscalationsCreatePathResultV2]:
        """
        Create an escalation path.

        An escalation path is a series of steps that describe how a page should be escalated,
        represented as graph, supporting conditional branches based on alert priority and working
        intervals.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        name : str
            The name of this escalation path, for the user's reference.

        path : typing.Sequence[EscalationPathNodePayloadV2]
            The nodes that form the levels and branches of this escalation path.

        team_ids : typing.Optional[typing.Sequence[str]]
            IDs of the teams that own this escalation path. This will automatically sync escalation paths with the right teams in Catalog. If you have an escalation paths attribute on your Teams, this attribute is required.

        working_hours : typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]]
            The working hours for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EscalationsCreatePathResultV2]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/escalation_paths",
            method="POST",
            json={
                "name": name,
                "path": convert_and_respect_annotation_metadata(
                    object_=path, annotation=typing.Sequence[EscalationPathNodePayloadV2], direction="write"
                ),
                "team_ids": team_ids,
                "working_hours": convert_and_respect_annotation_metadata(
                    object_=working_hours, annotation=typing.Sequence[WeekdayIntervalConfigV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsCreatePathResultV2,
                    parse_obj_as(
                        type_=EscalationsCreatePathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showpath(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EscalationsShowPathResultV2]:
        """
        Show an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EscalationsShowPathResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsShowPathResultV2,
                    parse_obj_as(
                        type_=EscalationsShowPathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updatepath(
        self,
        id: str,
        *,
        name: str,
        path: typing.Sequence[EscalationPathNodePayloadV2],
        team_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        working_hours: typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EscalationsUpdatePathResultV2]:
        """
        Updates an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        name : str
            The name of this escalation path, for the user's reference.

        path : typing.Sequence[EscalationPathNodePayloadV2]
            The nodes that form the levels and branches of this escalation path.

        team_ids : typing.Optional[typing.Sequence[str]]
            IDs of the teams that own this escalation path. This will automatically sync escalation paths with the right teams in Catalog. If you have an escalation paths attribute on your Teams, this attribute is required.

        working_hours : typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]]
            The working hours for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EscalationsUpdatePathResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "name": name,
                "path": convert_and_respect_annotation_metadata(
                    object_=path, annotation=typing.Sequence[EscalationPathNodePayloadV2], direction="write"
                ),
                "team_ids": team_ids,
                "working_hours": convert_and_respect_annotation_metadata(
                    object_=working_hours, annotation=typing.Sequence[WeekdayIntervalConfigV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsUpdatePathResultV2,
                    parse_obj_as(
                        type_=EscalationsUpdatePathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroypath(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Archives an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        escalation_path: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        alert: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        updated_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        idempotency_key: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EscalationsListResultV2]:
        """
        List all escalations for your account.
        
        This endpoint supports a number of filters, which can help find escalations matching certain
        criteria.
        
        Note that:
        - Filters may be used together, and the result will be escalations that match all filters.
        - All query parameters must be URI encoded.
        
        To use this API, you will need an API key with the "View data" or "Create and manage on-call resources" permission.
        
        ### By escalation_path
        
        Find all escalations that escalated to escalation path with id=ABC:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'escalation_path[one_of]=ABC'
        
        ### By status
        
        Find all escalations with a current status of "triggered":
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'status[one_of]=triggered'
        
        Possible values are "pending", "triggered", "acked", "resolved", "expired" and "cancelled".
        Escalations are in "pending" when they are in a grace period when the related alert has
        been grouped in an incident.
        
        ### By alert
        
        Find all escalations that were created by alert with id=ABC:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'alert[one_of]=ABC'
        
        ### By created_at and updated_at
        Find all escalations that follow specified date parameters for created_at and updated_at fields.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
        "date_range" (between two dates).
        For example, to find all escalations updated after 2025-01-01:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'updated_at[gte]=2025-01-01'
        
        To find all escalations created between 2025-01-01 and 2025-01-31:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'created_at[date_range]=2025-01-01~2025-01-31'
        
        Parameters
        ----------
        page_size : typing.Optional[int]
            Number of escalations to return per page
        
        after : typing.Optional[str]
            An escalation's ID. This endpoint will return a list of escalations after this ID in relation to the API response order.
        
        escalation_path : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the escalation path for which the escalation was triggered. Accepted operators are 'one_of' and 'not_in'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the status of the escalation. Accepted operators are 'one_of' and 'not_in'.
        
        alert : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the alert that created an escalation. Accepted operators are 'one_of' and 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the created_at timestamp of the escalation. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        updated_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the updated_at timestamp of the escalation. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        idempotency_key : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the idempotency key of the escalation. This is the key set when creating escalations via the API, and is distinct from alert deduplication keys. Accepted operators are 'is' for exact matches and 'starts_with' for prefix matching.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[EscalationsListResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/escalations",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "escalation_path": escalation_path,
                "status": status,
                "alert": alert,
                "created_at": created_at,
                "updated_at": updated_at,
                "idempotency_key": idempotency_key,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsListResultV2,
                    parse_obj_as(
                        type_=EscalationsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        idempotency_key: str,
        title: str,
        description: typing.Optional[str] = OMIT,
        escalation_path_id: typing.Optional[str] = OMIT,
        user_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EscalationsCreateResultV2]:
        """
        Create an escalation.

        An escalation pages people, either according to an escalation path, or directly to
        specific users. You must provide either an escalation_path_id OR user_ids, but not both.

        When escalating via an escalation path, the escalation will follow the configured path
        with its levels and timeouts, using your default [alert
        priority](https://app.incident.io/~/settings/alerts/configuration/priorities).

        When escalating directly to users, they will receive a high-urgency
        notification, based on their notification rules.

        This endpoint is rate-limited to 60 requests per minute, since it is intended for
        interactive use cases (for example someone clicking a "escalate to team" button
        in your internal developer platform). To escalate based on automated alerts, we
        recommend sending events to an alert source instead.

        Parameters
        ----------
        idempotency_key : str
            Unique key to prevent duplicate escalations. If this key has already been used, the existing escalation will be returned.

        title : str
            The title of the escalation. This message will be included in all notifications about this escalation.

        description : typing.Optional[str]
            Additional details about the escalation

        escalation_path_id : typing.Optional[str]
            ID of the escalation path to follow

        user_ids : typing.Optional[typing.Sequence[str]]
            IDs of users to escalate directly to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EscalationsCreateResultV2]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/escalations",
            method="POST",
            json={
                "description": description,
                "escalation_path_id": escalation_path_id,
                "idempotency_key": idempotency_key,
                "title": title,
                "user_ids": user_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsCreateResultV2,
                    parse_obj_as(
                        type_=EscalationsCreateResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EscalationsShowResultV2]:
        """
        Show a specific escalation.

        Parameters
        ----------
        id : str
            Unique ID of the escalation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EscalationsShowResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/escalations/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsShowResultV2,
                    parse_obj_as(
                        type_=EscalationsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEscalationsV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def createpath(
        self,
        *,
        name: str,
        path: typing.Sequence[EscalationPathNodePayloadV2],
        team_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        working_hours: typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EscalationsCreatePathResultV2]:
        """
        Create an escalation path.

        An escalation path is a series of steps that describe how a page should be escalated,
        represented as graph, supporting conditional branches based on alert priority and working
        intervals.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        name : str
            The name of this escalation path, for the user's reference.

        path : typing.Sequence[EscalationPathNodePayloadV2]
            The nodes that form the levels and branches of this escalation path.

        team_ids : typing.Optional[typing.Sequence[str]]
            IDs of the teams that own this escalation path. This will automatically sync escalation paths with the right teams in Catalog. If you have an escalation paths attribute on your Teams, this attribute is required.

        working_hours : typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]]
            The working hours for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EscalationsCreatePathResultV2]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/escalation_paths",
            method="POST",
            json={
                "name": name,
                "path": convert_and_respect_annotation_metadata(
                    object_=path, annotation=typing.Sequence[EscalationPathNodePayloadV2], direction="write"
                ),
                "team_ids": team_ids,
                "working_hours": convert_and_respect_annotation_metadata(
                    object_=working_hours, annotation=typing.Sequence[WeekdayIntervalConfigV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsCreatePathResultV2,
                    parse_obj_as(
                        type_=EscalationsCreatePathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showpath(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EscalationsShowPathResultV2]:
        """
        Show an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EscalationsShowPathResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsShowPathResultV2,
                    parse_obj_as(
                        type_=EscalationsShowPathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updatepath(
        self,
        id: str,
        *,
        name: str,
        path: typing.Sequence[EscalationPathNodePayloadV2],
        team_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        working_hours: typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EscalationsUpdatePathResultV2]:
        """
        Updates an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        name : str
            The name of this escalation path, for the user's reference.

        path : typing.Sequence[EscalationPathNodePayloadV2]
            The nodes that form the levels and branches of this escalation path.

        team_ids : typing.Optional[typing.Sequence[str]]
            IDs of the teams that own this escalation path. This will automatically sync escalation paths with the right teams in Catalog. If you have an escalation paths attribute on your Teams, this attribute is required.

        working_hours : typing.Optional[typing.Sequence[WeekdayIntervalConfigV2]]
            The working hours for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EscalationsUpdatePathResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "name": name,
                "path": convert_and_respect_annotation_metadata(
                    object_=path, annotation=typing.Sequence[EscalationPathNodePayloadV2], direction="write"
                ),
                "team_ids": team_ids,
                "working_hours": convert_and_respect_annotation_metadata(
                    object_=working_hours, annotation=typing.Sequence[WeekdayIntervalConfigV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsUpdatePathResultV2,
                    parse_obj_as(
                        type_=EscalationsUpdatePathResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroypath(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives an escalation path.

        We recommend you create escalation paths in the incident.io dashboard where our path
        builder makes it easy to use conditions and visualise the path.

        Parameters
        ----------
        id : str
            Unique identifier for this escalation path.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/escalation_paths/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        escalation_path: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        alert: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        updated_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        idempotency_key: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EscalationsListResultV2]:
        """
        List all escalations for your account.
        
        This endpoint supports a number of filters, which can help find escalations matching certain
        criteria.
        
        Note that:
        - Filters may be used together, and the result will be escalations that match all filters.
        - All query parameters must be URI encoded.
        
        To use this API, you will need an API key with the "View data" or "Create and manage on-call resources" permission.
        
        ### By escalation_path
        
        Find all escalations that escalated to escalation path with id=ABC:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'escalation_path[one_of]=ABC'
        
        ### By status
        
        Find all escalations with a current status of "triggered":
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'status[one_of]=triggered'
        
        Possible values are "pending", "triggered", "acked", "resolved", "expired" and "cancelled".
        Escalations are in "pending" when they are in a grace period when the related alert has
        been grouped in an incident.
        
        ### By alert
        
        Find all escalations that were created by alert with id=ABC:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'alert[one_of]=ABC'
        
        ### By created_at and updated_at
        Find all escalations that follow specified date parameters for created_at and updated_at fields.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
        "date_range" (between two dates).
        For example, to find all escalations updated after 2025-01-01:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'updated_at[gte]=2025-01-01'
        
        To find all escalations created between 2025-01-01 and 2025-01-31:
        
                curl --get 'https://api.incident.io/v2/escalations' \\
                    --data 'created_at[date_range]=2025-01-01~2025-01-31'
        
        Parameters
        ----------
        page_size : typing.Optional[int]
            Number of escalations to return per page
        
        after : typing.Optional[str]
            An escalation's ID. This endpoint will return a list of escalations after this ID in relation to the API response order.
        
        escalation_path : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the escalation path for which the escalation was triggered. Accepted operators are 'one_of' and 'not_in'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the status of the escalation. Accepted operators are 'one_of' and 'not_in'.
        
        alert : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the alert that created an escalation. Accepted operators are 'one_of' and 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the created_at timestamp of the escalation. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        updated_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the updated_at timestamp of the escalation. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        idempotency_key : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on the idempotency key of the escalation. This is the key set when creating escalations via the API, and is distinct from alert deduplication keys. Accepted operators are 'is' for exact matches and 'starts_with' for prefix matching.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[EscalationsListResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/escalations",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "escalation_path": escalation_path,
                "status": status,
                "alert": alert,
                "created_at": created_at,
                "updated_at": updated_at,
                "idempotency_key": idempotency_key,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsListResultV2,
                    parse_obj_as(
                        type_=EscalationsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        idempotency_key: str,
        title: str,
        description: typing.Optional[str] = OMIT,
        escalation_path_id: typing.Optional[str] = OMIT,
        user_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EscalationsCreateResultV2]:
        """
        Create an escalation.

        An escalation pages people, either according to an escalation path, or directly to
        specific users. You must provide either an escalation_path_id OR user_ids, but not both.

        When escalating via an escalation path, the escalation will follow the configured path
        with its levels and timeouts, using your default [alert
        priority](https://app.incident.io/~/settings/alerts/configuration/priorities).

        When escalating directly to users, they will receive a high-urgency
        notification, based on their notification rules.

        This endpoint is rate-limited to 60 requests per minute, since it is intended for
        interactive use cases (for example someone clicking a "escalate to team" button
        in your internal developer platform). To escalate based on automated alerts, we
        recommend sending events to an alert source instead.

        Parameters
        ----------
        idempotency_key : str
            Unique key to prevent duplicate escalations. If this key has already been used, the existing escalation will be returned.

        title : str
            The title of the escalation. This message will be included in all notifications about this escalation.

        description : typing.Optional[str]
            Additional details about the escalation

        escalation_path_id : typing.Optional[str]
            ID of the escalation path to follow

        user_ids : typing.Optional[typing.Sequence[str]]
            IDs of users to escalate directly to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EscalationsCreateResultV2]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/escalations",
            method="POST",
            json={
                "description": description,
                "escalation_path_id": escalation_path_id,
                "idempotency_key": idempotency_key,
                "title": title,
                "user_ids": user_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsCreateResultV2,
                    parse_obj_as(
                        type_=EscalationsCreateResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EscalationsShowResultV2]:
        """
        Show a specific escalation.

        Parameters
        ----------
        id : str
            Unique ID of the escalation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EscalationsShowResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/escalations/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EscalationsShowResultV2,
                    parse_obj_as(
                        type_=EscalationsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.catalog_create_entry_result_v3 import CatalogCreateEntryResultV3
from ..types.catalog_create_type_result_v3 import CatalogCreateTypeResultV3
from ..types.catalog_engine_param_binding_payload_v3 import CatalogEngineParamBindingPayloadV3
from ..types.catalog_list_entries_result_v3 import CatalogListEntriesResultV3
from ..types.catalog_list_resources_result_v3 import CatalogListResourcesResultV3
from ..types.catalog_list_types_result_v3 import CatalogListTypesResultV3
from ..types.catalog_show_entry_result_v3 import CatalogShowEntryResultV3
from ..types.catalog_show_type_result_v3 import CatalogShowTypeResultV3
from ..types.catalog_type_attribute_payload_v3 import CatalogTypeAttributePayloadV3
from ..types.catalog_update_entry_result_v3 import CatalogUpdateEntryResultV3
from ..types.catalog_update_type_result_v3 import CatalogUpdateTypeResultV3
from ..types.catalog_update_type_schema_result_v3 import CatalogUpdateTypeSchemaResultV3
from ..types.partial_entry_payload_v3 import PartialEntryPayloadV3
from .types.catalog_create_type_payload_v3categories_item import CatalogCreateTypePayloadV3CategoriesItem
from .types.catalog_create_type_payload_v3color import CatalogCreateTypePayloadV3Color
from .types.catalog_create_type_payload_v3icon import CatalogCreateTypePayloadV3Icon
from .types.catalog_update_type_payload_v3categories_item import CatalogUpdateTypePayloadV3CategoriesItem
from .types.catalog_update_type_payload_v3color import CatalogUpdateTypePayloadV3Color
from .types.catalog_update_type_payload_v3icon import CatalogUpdateTypePayloadV3Icon

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCatalogV3Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def listentries(
        self,
        *,
        catalog_type_id: str,
        page_size: int,
        after: typing.Optional[str] = None,
        identifier: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogListEntriesResultV3]:
        """
        List entries for a catalog type.

        Parameters
        ----------
        catalog_type_id : str
            ID of this catalog type

        page_size : int
            The integer number of records to return

        after : typing.Optional[str]
            An record's ID. This endpoint will return a list of records after this ID in relation to the API response order.

        identifier : typing.Optional[str]
            If specified, only entries with this identifier will be returned. This will search by ID, external ID, and aliases.

            If 'use name as identifier' is enabled for the catalog type, this will also match on name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListEntriesResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_entries",
            method="GET",
            params={
                "catalog_type_id": catalog_type_id,
                "page_size": page_size,
                "after": after,
                "identifier": identifier,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListEntriesResultV3,
                    parse_obj_as(
                        type_=CatalogListEntriesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def createentry(
        self,
        *,
        attribute_values: typing.Dict[str, CatalogEngineParamBindingPayloadV3],
        catalog_type_id: str,
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogCreateEntryResultV3]:
        """
        Create an entry within the catalog. We support a maximum of 50,000 entries per type.

        If you call this API with a payload where the external_id and catalog_type_id match an existing entry, the existing entry will be updated.

        Parameters
        ----------
        attribute_values : typing.Dict[str, CatalogEngineParamBindingPayloadV3]
            Values of this entry

        catalog_type_id : str
            ID of this catalog type

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogCreateEntryResultV3]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_entries",
            method="POST",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, CatalogEngineParamBindingPayloadV3],
                    direction="write",
                ),
                "catalog_type_id": catalog_type_id,
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateEntryResultV3,
                    parse_obj_as(
                        type_=CatalogCreateEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def bulkupdateentries(
        self,
        *,
        catalog_type_id: str,
        entries: typing.Sequence[PartialEntryPayloadV3],
        update_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Update multiple catalog entries in a single operation. You can update up to 250 entries at once. This operation is atomic - either all entries are updated successfully, or none are updated.

        Parameters
        ----------
        catalog_type_id : str
            The unique identifier of the catalog type containing the entries

        entries : typing.Sequence[PartialEntryPayloadV3]
            A list of entries to update with their new values. Maximum 250 entries per request.

        update_attributes : typing.Optional[typing.Sequence[str]]
            Optional list of specific attribute IDs to update across all entries. When provided, only these attributes in attribute_values will be updated and all other attributes will be preserved. This parameter only affects attribute_values - it does not affect core entry fields like name, rank, aliases, or external_id, which follow their individual omission rules.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_entries/actions/bulk_update",
            method="POST",
            json={
                "catalog_type_id": catalog_type_id,
                "entries": convert_and_respect_annotation_metadata(
                    object_=entries, annotation=typing.Sequence[PartialEntryPayloadV3], direction="write"
                ),
                "update_attributes": update_attributes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogShowEntryResultV3]:
        """
        Show a single catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogShowEntryResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowEntryResultV3,
                    parse_obj_as(
                        type_=CatalogShowEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updateentry(
        self,
        id: str,
        *,
        attribute_values: typing.Dict[str, CatalogEngineParamBindingPayloadV3],
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        update_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateEntryResultV3]:
        """
        Updates an existing catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        attribute_values : typing.Dict[str, CatalogEngineParamBindingPayloadV3]
            Values of this entry

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        update_attributes : typing.Optional[typing.Sequence[str]]
            If provided, only update these attribute_values keys. If not provided, update all attribute values.
            If you specify an attribute key that's not in your payload, the associated attribute value will be cleared.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateEntryResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, CatalogEngineParamBindingPayloadV3],
                    direction="write",
                ),
                "external_id": external_id,
                "name": name,
                "rank": rank,
                "update_attributes": update_attributes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateEntryResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroyentry(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Archives a catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def listresources(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogListResourcesResultV3]:
        """
        List available engine resources for the catalog.

        A resource represents a type of data that can be held within the catalog, so this
        endpoint can be used to see what attribute types can be used when updating the
        schema of a catalog type.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListResourcesResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_resources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListResourcesResultV3,
                    parse_obj_as(
                        type_=CatalogListResourcesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def listtypes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogListTypesResultV3]:
        """
        List all catalog types for an organisation, including those synced from external resources.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListTypesResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_types",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListTypesResultV3,
                    parse_obj_as(
                        type_=CatalogListTypesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def createtype(
        self,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogCreateTypePayloadV3CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogCreateTypePayloadV3Color] = OMIT,
        icon: typing.Optional[CatalogCreateTypePayloadV3Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        type_name: typing.Optional[str] = OMIT,
        use_name_as_identifier: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogCreateTypeResultV3]:
        """
        Create a catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogCreateTypePayloadV3CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogCreateTypePayloadV3Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogCreateTypePayloadV3Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        type_name : typing.Optional[str]
            The type name of this catalog type, to be used when defining attributes. This is immutable once a CatalogType has been created. For non-externally sync types, it must follow the pattern Custom["SomeName"]

        use_name_as_identifier : typing.Optional[bool]
            If enabled, you can refer to entries of this type by their name, as well as their external ID and any aliases.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogCreateTypeResultV3]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v3/catalog_types",
            method="POST",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "type_name": type_name,
                "use_name_as_identifier": use_name_as_identifier,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateTypeResultV3,
                    parse_obj_as(
                        type_=CatalogCreateTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showtype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogShowTypeResultV3]:
        """
        Show a single catalog type.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogShowTypeResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowTypeResultV3,
                    parse_obj_as(
                        type_=CatalogShowTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updatetype(
        self,
        id: str,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV3CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogUpdateTypePayloadV3Color] = OMIT,
        icon: typing.Optional[CatalogUpdateTypePayloadV3Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        use_name_as_identifier: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateTypeResultV3]:
        """
        Updates an existing catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        id : str
            ID of this catalog type

        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV3CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogUpdateTypePayloadV3Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogUpdateTypePayloadV3Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        use_name_as_identifier : typing.Optional[bool]
            If enabled, you can refer to entries of this type by their name, as well as their external ID and any aliases.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateTypeResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "use_name_as_identifier": use_name_as_identifier,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroytype(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Archives a catalog type and associated entries.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updatetypeschema(
        self,
        id: str,
        *,
        attributes: typing.Sequence[CatalogTypeAttributePayloadV3],
        version: int,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateTypeSchemaResultV3]:
        """
        Update an existing catalog types schema, adding or removing attributes.

        Updating the schema is handled separately from creating and updating types, so that you don't
        have to worry about dependencies between types. For example, if type A has an attribute that
        relies on type B, you would have to create type B first.

        By allowing the creation of types without a schema, they can be created in any order, but it
        means that you need to make a separate call to this endpoint to update the schema.

        Parameters
        ----------
        id : str
            ID of this catalog type

        attributes : typing.Sequence[CatalogTypeAttributePayloadV3]

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateTypeSchemaResultV3]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}/actions/update_schema",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CatalogTypeAttributePayloadV3], direction="write"
                ),
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeSchemaResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateTypeSchemaResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCatalogV3Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def listentries(
        self,
        *,
        catalog_type_id: str,
        page_size: int,
        after: typing.Optional[str] = None,
        identifier: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogListEntriesResultV3]:
        """
        List entries for a catalog type.

        Parameters
        ----------
        catalog_type_id : str
            ID of this catalog type

        page_size : int
            The integer number of records to return

        after : typing.Optional[str]
            An record's ID. This endpoint will return a list of records after this ID in relation to the API response order.

        identifier : typing.Optional[str]
            If specified, only entries with this identifier will be returned. This will search by ID, external ID, and aliases.

            If 'use name as identifier' is enabled for the catalog type, this will also match on name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListEntriesResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_entries",
            method="GET",
            params={
                "catalog_type_id": catalog_type_id,
                "page_size": page_size,
                "after": after,
                "identifier": identifier,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListEntriesResultV3,
                    parse_obj_as(
                        type_=CatalogListEntriesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def createentry(
        self,
        *,
        attribute_values: typing.Dict[str, CatalogEngineParamBindingPayloadV3],
        catalog_type_id: str,
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogCreateEntryResultV3]:
        """
        Create an entry within the catalog. We support a maximum of 50,000 entries per type.

        If you call this API with a payload where the external_id and catalog_type_id match an existing entry, the existing entry will be updated.

        Parameters
        ----------
        attribute_values : typing.Dict[str, CatalogEngineParamBindingPayloadV3]
            Values of this entry

        catalog_type_id : str
            ID of this catalog type

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogCreateEntryResultV3]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_entries",
            method="POST",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, CatalogEngineParamBindingPayloadV3],
                    direction="write",
                ),
                "catalog_type_id": catalog_type_id,
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateEntryResultV3,
                    parse_obj_as(
                        type_=CatalogCreateEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def bulkupdateentries(
        self,
        *,
        catalog_type_id: str,
        entries: typing.Sequence[PartialEntryPayloadV3],
        update_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Update multiple catalog entries in a single operation. You can update up to 250 entries at once. This operation is atomic - either all entries are updated successfully, or none are updated.

        Parameters
        ----------
        catalog_type_id : str
            The unique identifier of the catalog type containing the entries

        entries : typing.Sequence[PartialEntryPayloadV3]
            A list of entries to update with their new values. Maximum 250 entries per request.

        update_attributes : typing.Optional[typing.Sequence[str]]
            Optional list of specific attribute IDs to update across all entries. When provided, only these attributes in attribute_values will be updated and all other attributes will be preserved. This parameter only affects attribute_values - it does not affect core entry fields like name, rank, aliases, or external_id, which follow their individual omission rules.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_entries/actions/bulk_update",
            method="POST",
            json={
                "catalog_type_id": catalog_type_id,
                "entries": convert_and_respect_annotation_metadata(
                    object_=entries, annotation=typing.Sequence[PartialEntryPayloadV3], direction="write"
                ),
                "update_attributes": update_attributes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogShowEntryResultV3]:
        """
        Show a single catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogShowEntryResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowEntryResultV3,
                    parse_obj_as(
                        type_=CatalogShowEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updateentry(
        self,
        id: str,
        *,
        attribute_values: typing.Dict[str, CatalogEngineParamBindingPayloadV3],
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        update_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateEntryResultV3]:
        """
        Updates an existing catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        attribute_values : typing.Dict[str, CatalogEngineParamBindingPayloadV3]
            Values of this entry

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        update_attributes : typing.Optional[typing.Sequence[str]]
            If provided, only update these attribute_values keys. If not provided, update all attribute values.
            If you specify an attribute key that's not in your payload, the associated attribute value will be cleared.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateEntryResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, CatalogEngineParamBindingPayloadV3],
                    direction="write",
                ),
                "external_id": external_id,
                "name": name,
                "rank": rank,
                "update_attributes": update_attributes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateEntryResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateEntryResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroyentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives a catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_entries/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def listresources(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogListResourcesResultV3]:
        """
        List available engine resources for the catalog.

        A resource represents a type of data that can be held within the catalog, so this
        endpoint can be used to see what attribute types can be used when updating the
        schema of a catalog type.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListResourcesResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_resources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListResourcesResultV3,
                    parse_obj_as(
                        type_=CatalogListResourcesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def listtypes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogListTypesResultV3]:
        """
        List all catalog types for an organisation, including those synced from external resources.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListTypesResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_types",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListTypesResultV3,
                    parse_obj_as(
                        type_=CatalogListTypesResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def createtype(
        self,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogCreateTypePayloadV3CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogCreateTypePayloadV3Color] = OMIT,
        icon: typing.Optional[CatalogCreateTypePayloadV3Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        type_name: typing.Optional[str] = OMIT,
        use_name_as_identifier: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogCreateTypeResultV3]:
        """
        Create a catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogCreateTypePayloadV3CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogCreateTypePayloadV3Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogCreateTypePayloadV3Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        type_name : typing.Optional[str]
            The type name of this catalog type, to be used when defining attributes. This is immutable once a CatalogType has been created. For non-externally sync types, it must follow the pattern Custom["SomeName"]

        use_name_as_identifier : typing.Optional[bool]
            If enabled, you can refer to entries of this type by their name, as well as their external ID and any aliases.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogCreateTypeResultV3]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v3/catalog_types",
            method="POST",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "type_name": type_name,
                "use_name_as_identifier": use_name_as_identifier,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateTypeResultV3,
                    parse_obj_as(
                        type_=CatalogCreateTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showtype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogShowTypeResultV3]:
        """
        Show a single catalog type.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogShowTypeResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowTypeResultV3,
                    parse_obj_as(
                        type_=CatalogShowTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updatetype(
        self,
        id: str,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV3CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogUpdateTypePayloadV3Color] = OMIT,
        icon: typing.Optional[CatalogUpdateTypePayloadV3Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        use_name_as_identifier: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateTypeResultV3]:
        """
        Updates an existing catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        id : str
            ID of this catalog type

        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV3CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogUpdateTypePayloadV3Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogUpdateTypePayloadV3Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        use_name_as_identifier : typing.Optional[bool]
            If enabled, you can refer to entries of this type by their name, as well as their external ID and any aliases.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateTypeResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "use_name_as_identifier": use_name_as_identifier,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateTypeResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroytype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives a catalog type and associated entries.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updatetypeschema(
        self,
        id: str,
        *,
        attributes: typing.Sequence[CatalogTypeAttributePayloadV3],
        version: int,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateTypeSchemaResultV3]:
        """
        Update an existing catalog types schema, adding or removing attributes.

        Updating the schema is handled separately from creating and updating types, so that you don't
        have to worry about dependencies between types. For example, if type A has an attribute that
        relies on type B, you would have to create type B first.

        By allowing the creation of types without a schema, they can be created in any order, but it
        means that you need to make a separate call to this endpoint to update the schema.

        Parameters
        ----------
        id : str
            ID of this catalog type

        attributes : typing.Sequence[CatalogTypeAttributePayloadV3]

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateTypeSchemaResultV3]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v3/catalog_types/{jsonable_encoder(id)}/actions/update_schema",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CatalogTypeAttributePayloadV3], direction="write"
                ),
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeSchemaResultV3,
                    parse_obj_as(
                        type_=CatalogUpdateTypeSchemaResultV3,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

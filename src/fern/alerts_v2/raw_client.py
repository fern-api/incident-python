# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..types.alerts_list_incident_alerts_result_v2 import AlertsListIncidentAlertsResultV2
from ..types.alerts_list_result_v2 import AlertsListResultV2
from ..types.alerts_show_result_v2 import AlertsShowResultV2


class RawAlertsV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page_size: int,
        after: typing.Optional[str] = None,
        deduplication_key: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AlertsListResultV2]:
        """
        List all alerts for your account.
                
        This endpoint supports a number of filters, which can help find alerts matching certain
        criteria. These filters work similarly to the filters on the incidents endpoint, where 
        a field is specified alongside a comparison operator in the query string.
        
        Note that:
        - Filters may be used together, and the result will be alerts that match all filters.
        - All query parameters must be URI encoded.
        
        ### By deduplication_key
        
        Find all alerts with deduplication_key ABC:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'deduplication_key[is]=ABC'
        
        ### By status
        
        Find all alerts in a firing state:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'status[one_of]=firing'
        
        ### By created_at
        Find all alerts that follow specified date parameters for created_at field.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and 
        "date_range" (between two dates). The following example finds all alerts created after 
        2025-01-01:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'created_at[gte]=2025-01-01'
        
        To find alerts created within a specific date range, use the date_range option with 
        tilde-separated dates:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'created_at[date_range]=2024-12-02~2024-12-08'
                
        
        Parameters
        ----------
        page_size : int
            Number of alerts to return per page
        
        after : typing.Optional[str]
            If provided, pass this as the 'after' param to load the next page
        
        deduplication_key : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert deduplication key. The accepted operator is 'is'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert status. The accepted operators are 'one_of', or 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert created at timestamp. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[AlertsListResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/alerts",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "deduplication_key": deduplication_key,
                "status": status,
                "created_at": created_at,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsListResultV2,
                    parse_obj_as(
                        type_=AlertsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AlertsShowResultV2]:
        """
        Show a single alert for your account

        Parameters
        ----------
        id : str
            Unique identifier for the alert

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AlertsShowResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/alerts/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsShowResultV2,
                    parse_obj_as(
                        type_=AlertsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def listincidentalerts(
        self,
        *,
        page_size: int,
        after: typing.Optional[str] = None,
        alert_id: typing.Optional[str] = None,
        incident_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AlertsListIncidentAlertsResultV2]:
        """
        List the connections between incidents and alerts

        Parameters
        ----------
        page_size : int
            Number of incident alerts to return per page

        after : typing.Optional[str]
            If provided, pass this as the 'after' param to load the next page

        alert_id : typing.Optional[str]
            Alert that this incident alert refers to

        incident_id : typing.Optional[str]
            Incident that this incident alert is attached to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AlertsListIncidentAlertsResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/incident_alerts",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "alert_id": alert_id,
                "incident_id": incident_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsListIncidentAlertsResultV2,
                    parse_obj_as(
                        type_=AlertsListIncidentAlertsResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawAlertsV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page_size: int,
        after: typing.Optional[str] = None,
        deduplication_key: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        status: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        created_at: typing.Optional[typing.Dict[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AlertsListResultV2]:
        """
        List all alerts for your account.
                
        This endpoint supports a number of filters, which can help find alerts matching certain
        criteria. These filters work similarly to the filters on the incidents endpoint, where 
        a field is specified alongside a comparison operator in the query string.
        
        Note that:
        - Filters may be used together, and the result will be alerts that match all filters.
        - All query parameters must be URI encoded.
        
        ### By deduplication_key
        
        Find all alerts with deduplication_key ABC:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'deduplication_key[is]=ABC'
        
        ### By status
        
        Find all alerts in a firing state:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'status[one_of]=firing'
        
        ### By created_at
        Find all alerts that follow specified date parameters for created_at field.
        Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and 
        "date_range" (between two dates). The following example finds all alerts created after 
        2025-01-01:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'created_at[gte]=2025-01-01'
        
        To find alerts created within a specific date range, use the date_range option with 
        tilde-separated dates:
        
                curl --get 'https://api.incident.io/v2/alerts' \\
                    --data 'created_at[date_range]=2024-12-02~2024-12-08'
                
        
        Parameters
        ----------
        page_size : int
            Number of alerts to return per page
        
        after : typing.Optional[str]
            If provided, pass this as the 'after' param to load the next page
        
        deduplication_key : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert deduplication key. The accepted operator is 'is'.
        
        status : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert status. The accepted operators are 'one_of', or 'not_in'.
        
        created_at : typing.Optional[typing.Dict[str, typing.Sequence[str]]]
            Filter on alert created at timestamp. Accepted operators are 'gte', 'lte' and 'date_range'.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[AlertsListResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/alerts",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "deduplication_key": deduplication_key,
                "status": status,
                "created_at": created_at,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsListResultV2,
                    parse_obj_as(
                        type_=AlertsListResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def show(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AlertsShowResultV2]:
        """
        Show a single alert for your account

        Parameters
        ----------
        id : str
            Unique identifier for the alert

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AlertsShowResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/alerts/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsShowResultV2,
                    parse_obj_as(
                        type_=AlertsShowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def listincidentalerts(
        self,
        *,
        page_size: int,
        after: typing.Optional[str] = None,
        alert_id: typing.Optional[str] = None,
        incident_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AlertsListIncidentAlertsResultV2]:
        """
        List the connections between incidents and alerts

        Parameters
        ----------
        page_size : int
            Number of incident alerts to return per page

        after : typing.Optional[str]
            If provided, pass this as the 'after' param to load the next page

        alert_id : typing.Optional[str]
            Alert that this incident alert refers to

        incident_id : typing.Optional[str]
            Incident that this incident alert is attached to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AlertsListIncidentAlertsResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/incident_alerts",
            method="GET",
            params={
                "page_size": page_size,
                "after": after,
                "alert_id": alert_id,
                "incident_id": incident_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertsListIncidentAlertsResultV2,
                    parse_obj_as(
                        type_=AlertsListIncidentAlertsResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

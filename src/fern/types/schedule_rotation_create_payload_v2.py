# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .schedule_layer_create_payload_v2 import ScheduleLayerCreatePayloadV2
from .schedule_rotation_create_payload_v2scheduling_mode import ScheduleRotationCreatePayloadV2SchedulingMode
from .schedule_rotation_handover_v2 import ScheduleRotationHandoverV2
from .schedule_rotation_working_interval_create_payload_v2 import ScheduleRotationWorkingIntervalCreatePayloadV2
from .user_reference_payload_v2 import UserReferencePayloadV2


class ScheduleRotationCreatePayloadV2(UniversalBaseModel):
    effective_from: typing.Optional[dt.datetime] = None
    handover_start_at: typing.Optional[dt.datetime] = None
    handovers: typing.Optional[typing.List[ScheduleRotationHandoverV2]] = None
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unique identifier of the rotation
    """

    layers: typing.Optional[typing.List[ScheduleLayerCreatePayloadV2]] = None
    name: str = pydantic.Field()
    """
    Name of the rotation
    """

    scheduling_mode: typing.Optional[ScheduleRotationCreatePayloadV2SchedulingMode] = pydantic.Field(default=None)
    """
    Scheduling algorithm to use for this rotation. 'fair' balances workload by considering handover duration, while 'sequential' uses simple round-robin rotation through users. Only applies when you have asymmetric handovers (e.g., 2 days then 5 days).
    """

    users: typing.Optional[typing.List[UserReferencePayloadV2]] = None
    working_interval: typing.Optional[typing.List[ScheduleRotationWorkingIntervalCreatePayloadV2]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .schedule_layer_update_payload_v2 import ScheduleLayerUpdatePayloadV2
from .schedule_rotation_handover_v2 import ScheduleRotationHandoverV2
from .schedule_rotation_update_payload_v2scheduling_mode import ScheduleRotationUpdatePayloadV2SchedulingMode
from .schedule_rotation_working_interval_v2 import ScheduleRotationWorkingIntervalV2
from .user_reference_payload_v2 import UserReferencePayloadV2


class ScheduleRotationUpdatePayloadV2(UniversalBaseModel):
    effective_from: typing.Optional[dt.datetime] = None
    handover_start_at: typing.Optional[dt.datetime] = None
    handovers: typing.Optional[typing.List[ScheduleRotationHandoverV2]] = None
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    Unique identifier of the rotation
    """

    layers: typing.Optional[typing.List[ScheduleLayerUpdatePayloadV2]] = None
    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    Name of the rotation
    """

    scheduling_mode: typing.Optional[ScheduleRotationUpdatePayloadV2SchedulingMode] = pydantic.Field(default=None)
    """
    Scheduling algorithm to use for this rotation. 'fair' balances workload by considering handover duration, while 'sequential' uses simple round-robin rotation through users. Only applies when you have asymmetric handovers (e.g., 2 days then 5 days).
    """

    users: typing.Optional[typing.List[UserReferencePayloadV2]] = None
    working_interval: typing.Optional[typing.List[ScheduleRotationWorkingIntervalV2]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow

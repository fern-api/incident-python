# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.condition_group_payload_v2 import ConditionGroupPayloadV2
from ..types.expression_payload_v2 import ExpressionPayloadV2
from ..types.step_config_payload_v2 import StepConfigPayloadV2
from ..types.workflow_delay_v2 import WorkflowDelayV2
from ..types.workflows_create_workflow_result_v2 import WorkflowsCreateWorkflowResultV2
from ..types.workflows_list_workflows_result_v2 import WorkflowsListWorkflowsResultV2
from ..types.workflows_show_workflow_result_v2 import WorkflowsShowWorkflowResultV2
from ..types.workflows_update_workflow_result_v2 import WorkflowsUpdateWorkflowResultV2
from .types.workflows_create_workflow_payload_v2runs_on_incident_modes_item import (
    WorkflowsCreateWorkflowPayloadV2RunsOnIncidentModesItem,
)
from .types.workflows_create_workflow_payload_v2runs_on_incidents import WorkflowsCreateWorkflowPayloadV2RunsOnIncidents
from .types.workflows_create_workflow_payload_v2state import WorkflowsCreateWorkflowPayloadV2State
from .types.workflows_update_workflow_payload_v2runs_on_incident_modes_item import (
    WorkflowsUpdateWorkflowPayloadV2RunsOnIncidentModesItem,
)
from .types.workflows_update_workflow_payload_v2runs_on_incidents import WorkflowsUpdateWorkflowPayloadV2RunsOnIncidents
from .types.workflows_update_workflow_payload_v2state import WorkflowsUpdateWorkflowPayloadV2State

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWorkflowsV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def listworkflows(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowsListWorkflowsResultV2]:
        """
        List all workflows

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowsListWorkflowsResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/workflows",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsListWorkflowsResultV2,
                    parse_obj_as(
                        type_=WorkflowsListWorkflowsResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def createworkflow(
        self,
        *,
        condition_groups: typing.Sequence[ConditionGroupPayloadV2],
        continue_on_step_error: bool,
        expressions: typing.Sequence[ExpressionPayloadV2],
        include_private_incidents: bool,
        name: str,
        once_for: typing.Sequence[str],
        runs_on_incident_modes: typing.Sequence[WorkflowsCreateWorkflowPayloadV2RunsOnIncidentModesItem],
        runs_on_incidents: WorkflowsCreateWorkflowPayloadV2RunsOnIncidents,
        steps: typing.Sequence[StepConfigPayloadV2],
        trigger: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        delay: typing.Optional[WorkflowDelayV2] = OMIT,
        folder: typing.Optional[str] = OMIT,
        include_private_escalations: typing.Optional[bool] = OMIT,
        shortform: typing.Optional[str] = OMIT,
        state: typing.Optional[WorkflowsCreateWorkflowPayloadV2State] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowsCreateWorkflowResultV2]:
        """
        Create a new workflow

        Parameters
        ----------
        condition_groups : typing.Sequence[ConditionGroupPayloadV2]
            Conditions that apply to the workflow trigger

        continue_on_step_error : bool
            Whether to continue executing the workflow if a step fails

        expressions : typing.Sequence[ExpressionPayloadV2]
            The expressions to use in the workflow

        include_private_incidents : bool
            Whether to include private incidents

        name : str
            Name provided by the user when creating the workflow

        once_for : typing.Sequence[str]
            This workflow will run 'once for' a list of references

        runs_on_incident_modes : typing.Sequence[WorkflowsCreateWorkflowPayloadV2RunsOnIncidentModesItem]
            Which incident modes should this workflow run on? By default, workflows only run on standard incidents, but can also be configured to run on test and retrospective incidents.

        runs_on_incidents : WorkflowsCreateWorkflowPayloadV2RunsOnIncidents
            Which incidents should the workflow be applied to?

        steps : typing.Sequence[StepConfigPayloadV2]
            Steps that are executed as part of the workflow

        trigger : str
            Trigger to set on the workflow

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that track metadata about this resource

        delay : typing.Optional[WorkflowDelayV2]

        folder : typing.Optional[str]
            Folder to display the workflow in

        include_private_escalations : typing.Optional[bool]
            Whether to include private escalations

        shortform : typing.Optional[str]
            The shortform used to trigger this workflow (only applicable for manual triggers)

        state : typing.Optional[WorkflowsCreateWorkflowPayloadV2State]
            What state this workflow is in

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowsCreateWorkflowResultV2]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/workflows",
            method="POST",
            json={
                "annotations": annotations,
                "condition_groups": convert_and_respect_annotation_metadata(
                    object_=condition_groups, annotation=typing.Sequence[ConditionGroupPayloadV2], direction="write"
                ),
                "continue_on_step_error": continue_on_step_error,
                "delay": convert_and_respect_annotation_metadata(
                    object_=delay, annotation=WorkflowDelayV2, direction="write"
                ),
                "expressions": convert_and_respect_annotation_metadata(
                    object_=expressions, annotation=typing.Sequence[ExpressionPayloadV2], direction="write"
                ),
                "folder": folder,
                "include_private_escalations": include_private_escalations,
                "include_private_incidents": include_private_incidents,
                "name": name,
                "once_for": once_for,
                "runs_on_incident_modes": runs_on_incident_modes,
                "runs_on_incidents": runs_on_incidents,
                "shortform": shortform,
                "state": state,
                "steps": convert_and_respect_annotation_metadata(
                    object_=steps, annotation=typing.Sequence[StepConfigPayloadV2], direction="write"
                ),
                "trigger": trigger,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsCreateWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsCreateWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showworkflow(
        self,
        id: str,
        *,
        skip_step_upgrades: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowsShowWorkflowResultV2]:
        """
        Show a workflow by ID

        Parameters
        ----------
        id : str
            Unique identifier for the workflow

        skip_step_upgrades : typing.Optional[bool]
            Skips workflow step upgrades, when the parameters for an existing workflow step change

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowsShowWorkflowResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="GET",
            params={
                "skip_step_upgrades": skip_step_upgrades,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsShowWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsShowWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updateworkflow(
        self,
        id: str,
        *,
        condition_groups: typing.Sequence[ConditionGroupPayloadV2],
        continue_on_step_error: bool,
        expressions: typing.Sequence[ExpressionPayloadV2],
        include_private_incidents: bool,
        name: str,
        once_for: typing.Sequence[str],
        runs_on_incident_modes: typing.Sequence[WorkflowsUpdateWorkflowPayloadV2RunsOnIncidentModesItem],
        runs_on_incidents: WorkflowsUpdateWorkflowPayloadV2RunsOnIncidents,
        steps: typing.Sequence[StepConfigPayloadV2],
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        delay: typing.Optional[WorkflowDelayV2] = OMIT,
        folder: typing.Optional[str] = OMIT,
        include_private_escalations: typing.Optional[bool] = OMIT,
        shortform: typing.Optional[str] = OMIT,
        state: typing.Optional[WorkflowsUpdateWorkflowPayloadV2State] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowsUpdateWorkflowResultV2]:
        """
        Updates a workflow

        Parameters
        ----------
        id : str
            ID of the workflow to update

        condition_groups : typing.Sequence[ConditionGroupPayloadV2]
            Conditions that apply to the workflow trigger

        continue_on_step_error : bool
            Whether to continue executing the workflow if a step fails

        expressions : typing.Sequence[ExpressionPayloadV2]
            The expressions to use in the workflow

        include_private_incidents : bool
            Whether to include private incidents

        name : str
            Name provided by the user when creating the workflow

        once_for : typing.Sequence[str]
            This workflow will run 'once for' a list of references

        runs_on_incident_modes : typing.Sequence[WorkflowsUpdateWorkflowPayloadV2RunsOnIncidentModesItem]
            Which incident modes should this workflow run on? By default, workflows only run on standard incidents, but can also be configured to run on test and retrospective incidents.

        runs_on_incidents : WorkflowsUpdateWorkflowPayloadV2RunsOnIncidents
            Which incidents should the workflow be applied to?

        steps : typing.Sequence[StepConfigPayloadV2]
            Steps that are executed as part of the workflow

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that track metadata about this resource

        delay : typing.Optional[WorkflowDelayV2]

        folder : typing.Optional[str]
            Folder to display the workflow in

        include_private_escalations : typing.Optional[bool]
            Whether to include private escalations

        shortform : typing.Optional[str]
            The shortform used to trigger this workflow (only applicable for manual triggers)

        state : typing.Optional[WorkflowsUpdateWorkflowPayloadV2State]
            What state this workflow is in

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowsUpdateWorkflowResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "condition_groups": convert_and_respect_annotation_metadata(
                    object_=condition_groups, annotation=typing.Sequence[ConditionGroupPayloadV2], direction="write"
                ),
                "continue_on_step_error": continue_on_step_error,
                "delay": convert_and_respect_annotation_metadata(
                    object_=delay, annotation=WorkflowDelayV2, direction="write"
                ),
                "expressions": convert_and_respect_annotation_metadata(
                    object_=expressions, annotation=typing.Sequence[ExpressionPayloadV2], direction="write"
                ),
                "folder": folder,
                "include_private_escalations": include_private_escalations,
                "include_private_incidents": include_private_incidents,
                "name": name,
                "once_for": once_for,
                "runs_on_incident_modes": runs_on_incident_modes,
                "runs_on_incidents": runs_on_incidents,
                "shortform": shortform,
                "state": state,
                "steps": convert_and_respect_annotation_metadata(
                    object_=steps, annotation=typing.Sequence[StepConfigPayloadV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsUpdateWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsUpdateWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroyworkflow(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Archives a workflow

        Parameters
        ----------
        id : str
            Unique identifier for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWorkflowsV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def listworkflows(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowsListWorkflowsResultV2]:
        """
        List all workflows

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowsListWorkflowsResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/workflows",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsListWorkflowsResultV2,
                    parse_obj_as(
                        type_=WorkflowsListWorkflowsResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def createworkflow(
        self,
        *,
        condition_groups: typing.Sequence[ConditionGroupPayloadV2],
        continue_on_step_error: bool,
        expressions: typing.Sequence[ExpressionPayloadV2],
        include_private_incidents: bool,
        name: str,
        once_for: typing.Sequence[str],
        runs_on_incident_modes: typing.Sequence[WorkflowsCreateWorkflowPayloadV2RunsOnIncidentModesItem],
        runs_on_incidents: WorkflowsCreateWorkflowPayloadV2RunsOnIncidents,
        steps: typing.Sequence[StepConfigPayloadV2],
        trigger: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        delay: typing.Optional[WorkflowDelayV2] = OMIT,
        folder: typing.Optional[str] = OMIT,
        include_private_escalations: typing.Optional[bool] = OMIT,
        shortform: typing.Optional[str] = OMIT,
        state: typing.Optional[WorkflowsCreateWorkflowPayloadV2State] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowsCreateWorkflowResultV2]:
        """
        Create a new workflow

        Parameters
        ----------
        condition_groups : typing.Sequence[ConditionGroupPayloadV2]
            Conditions that apply to the workflow trigger

        continue_on_step_error : bool
            Whether to continue executing the workflow if a step fails

        expressions : typing.Sequence[ExpressionPayloadV2]
            The expressions to use in the workflow

        include_private_incidents : bool
            Whether to include private incidents

        name : str
            Name provided by the user when creating the workflow

        once_for : typing.Sequence[str]
            This workflow will run 'once for' a list of references

        runs_on_incident_modes : typing.Sequence[WorkflowsCreateWorkflowPayloadV2RunsOnIncidentModesItem]
            Which incident modes should this workflow run on? By default, workflows only run on standard incidents, but can also be configured to run on test and retrospective incidents.

        runs_on_incidents : WorkflowsCreateWorkflowPayloadV2RunsOnIncidents
            Which incidents should the workflow be applied to?

        steps : typing.Sequence[StepConfigPayloadV2]
            Steps that are executed as part of the workflow

        trigger : str
            Trigger to set on the workflow

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that track metadata about this resource

        delay : typing.Optional[WorkflowDelayV2]

        folder : typing.Optional[str]
            Folder to display the workflow in

        include_private_escalations : typing.Optional[bool]
            Whether to include private escalations

        shortform : typing.Optional[str]
            The shortform used to trigger this workflow (only applicable for manual triggers)

        state : typing.Optional[WorkflowsCreateWorkflowPayloadV2State]
            What state this workflow is in

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowsCreateWorkflowResultV2]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/workflows",
            method="POST",
            json={
                "annotations": annotations,
                "condition_groups": convert_and_respect_annotation_metadata(
                    object_=condition_groups, annotation=typing.Sequence[ConditionGroupPayloadV2], direction="write"
                ),
                "continue_on_step_error": continue_on_step_error,
                "delay": convert_and_respect_annotation_metadata(
                    object_=delay, annotation=WorkflowDelayV2, direction="write"
                ),
                "expressions": convert_and_respect_annotation_metadata(
                    object_=expressions, annotation=typing.Sequence[ExpressionPayloadV2], direction="write"
                ),
                "folder": folder,
                "include_private_escalations": include_private_escalations,
                "include_private_incidents": include_private_incidents,
                "name": name,
                "once_for": once_for,
                "runs_on_incident_modes": runs_on_incident_modes,
                "runs_on_incidents": runs_on_incidents,
                "shortform": shortform,
                "state": state,
                "steps": convert_and_respect_annotation_metadata(
                    object_=steps, annotation=typing.Sequence[StepConfigPayloadV2], direction="write"
                ),
                "trigger": trigger,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsCreateWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsCreateWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showworkflow(
        self,
        id: str,
        *,
        skip_step_upgrades: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowsShowWorkflowResultV2]:
        """
        Show a workflow by ID

        Parameters
        ----------
        id : str
            Unique identifier for the workflow

        skip_step_upgrades : typing.Optional[bool]
            Skips workflow step upgrades, when the parameters for an existing workflow step change

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowsShowWorkflowResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="GET",
            params={
                "skip_step_upgrades": skip_step_upgrades,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsShowWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsShowWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updateworkflow(
        self,
        id: str,
        *,
        condition_groups: typing.Sequence[ConditionGroupPayloadV2],
        continue_on_step_error: bool,
        expressions: typing.Sequence[ExpressionPayloadV2],
        include_private_incidents: bool,
        name: str,
        once_for: typing.Sequence[str],
        runs_on_incident_modes: typing.Sequence[WorkflowsUpdateWorkflowPayloadV2RunsOnIncidentModesItem],
        runs_on_incidents: WorkflowsUpdateWorkflowPayloadV2RunsOnIncidents,
        steps: typing.Sequence[StepConfigPayloadV2],
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        delay: typing.Optional[WorkflowDelayV2] = OMIT,
        folder: typing.Optional[str] = OMIT,
        include_private_escalations: typing.Optional[bool] = OMIT,
        shortform: typing.Optional[str] = OMIT,
        state: typing.Optional[WorkflowsUpdateWorkflowPayloadV2State] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowsUpdateWorkflowResultV2]:
        """
        Updates a workflow

        Parameters
        ----------
        id : str
            ID of the workflow to update

        condition_groups : typing.Sequence[ConditionGroupPayloadV2]
            Conditions that apply to the workflow trigger

        continue_on_step_error : bool
            Whether to continue executing the workflow if a step fails

        expressions : typing.Sequence[ExpressionPayloadV2]
            The expressions to use in the workflow

        include_private_incidents : bool
            Whether to include private incidents

        name : str
            Name provided by the user when creating the workflow

        once_for : typing.Sequence[str]
            This workflow will run 'once for' a list of references

        runs_on_incident_modes : typing.Sequence[WorkflowsUpdateWorkflowPayloadV2RunsOnIncidentModesItem]
            Which incident modes should this workflow run on? By default, workflows only run on standard incidents, but can also be configured to run on test and retrospective incidents.

        runs_on_incidents : WorkflowsUpdateWorkflowPayloadV2RunsOnIncidents
            Which incidents should the workflow be applied to?

        steps : typing.Sequence[StepConfigPayloadV2]
            Steps that are executed as part of the workflow

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that track metadata about this resource

        delay : typing.Optional[WorkflowDelayV2]

        folder : typing.Optional[str]
            Folder to display the workflow in

        include_private_escalations : typing.Optional[bool]
            Whether to include private escalations

        shortform : typing.Optional[str]
            The shortform used to trigger this workflow (only applicable for manual triggers)

        state : typing.Optional[WorkflowsUpdateWorkflowPayloadV2State]
            What state this workflow is in

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowsUpdateWorkflowResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "condition_groups": convert_and_respect_annotation_metadata(
                    object_=condition_groups, annotation=typing.Sequence[ConditionGroupPayloadV2], direction="write"
                ),
                "continue_on_step_error": continue_on_step_error,
                "delay": convert_and_respect_annotation_metadata(
                    object_=delay, annotation=WorkflowDelayV2, direction="write"
                ),
                "expressions": convert_and_respect_annotation_metadata(
                    object_=expressions, annotation=typing.Sequence[ExpressionPayloadV2], direction="write"
                ),
                "folder": folder,
                "include_private_escalations": include_private_escalations,
                "include_private_incidents": include_private_incidents,
                "name": name,
                "once_for": once_for,
                "runs_on_incident_modes": runs_on_incident_modes,
                "runs_on_incidents": runs_on_incidents,
                "shortform": shortform,
                "state": state,
                "steps": convert_and_respect_annotation_metadata(
                    object_=steps, annotation=typing.Sequence[StepConfigPayloadV2], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsUpdateWorkflowResultV2,
                    parse_obj_as(
                        type_=WorkflowsUpdateWorkflowResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroyworkflow(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives a workflow

        Parameters
        ----------
        id : str
            Unique identifier for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/workflows/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

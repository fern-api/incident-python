# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..types.alert_events_create_http_result_v2 import AlertEventsCreateHttpResultV2
from .types.alert_events_create_http_payload_v2status import AlertEventsCreateHttpPayloadV2Status

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawAlertEventsV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def createhttp(
        self,
        alert_source_config_id: str,
        *,
        status: AlertEventsCreateHttpPayloadV2Status,
        title: str,
        token: typing.Optional[str] = None,
        deduplication_key: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        source_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AlertEventsCreateHttpResultV2]:
        """
        Create an alert event using an HTTP source.

        Parameters
        ----------
        alert_source_config_id : str
            Which alert source config produced this alert

        status : AlertEventsCreateHttpPayloadV2Status
            Current status of this alert

        title : str
            The title of the alert, parsed from the alert payload according to the alert source configuration

        token : typing.Optional[str]
            Token used to authenticate the request, generated when configuring the alert source. Will be consumed via a URL query string parameter

        deduplication_key : typing.Optional[str]
            A deduplication key which uniquely references this alert from your alert source. For newly created HTTP sources, this field is required.
            If you send an event with the same deduplication_key multiple times, only one alert will be created in incident.io for this alert source config.
            You can filter on this field to find the alert created by an event you've sent us.

        description : typing.Optional[str]
            Description that optionally adds more detail to title. Supports markdown.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]
            Any additional metadata that you've configured your alert source to parse

        source_url : typing.Optional[str]
            If applicable, a link to the alert in the upstream system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AlertEventsCreateHttpResultV2]
            Accepted response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/alert_events/http/{jsonable_encoder(alert_source_config_id)}",
            method="POST",
            params={
                "token": token,
            },
            json={
                "deduplication_key": deduplication_key,
                "description": description,
                "metadata": metadata,
                "source_url": source_url,
                "status": status,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertEventsCreateHttpResultV2,
                    parse_obj_as(
                        type_=AlertEventsCreateHttpResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawAlertEventsV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def createhttp(
        self,
        alert_source_config_id: str,
        *,
        status: AlertEventsCreateHttpPayloadV2Status,
        title: str,
        token: typing.Optional[str] = None,
        deduplication_key: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        source_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AlertEventsCreateHttpResultV2]:
        """
        Create an alert event using an HTTP source.

        Parameters
        ----------
        alert_source_config_id : str
            Which alert source config produced this alert

        status : AlertEventsCreateHttpPayloadV2Status
            Current status of this alert

        title : str
            The title of the alert, parsed from the alert payload according to the alert source configuration

        token : typing.Optional[str]
            Token used to authenticate the request, generated when configuring the alert source. Will be consumed via a URL query string parameter

        deduplication_key : typing.Optional[str]
            A deduplication key which uniquely references this alert from your alert source. For newly created HTTP sources, this field is required.
            If you send an event with the same deduplication_key multiple times, only one alert will be created in incident.io for this alert source config.
            You can filter on this field to find the alert created by an event you've sent us.

        description : typing.Optional[str]
            Description that optionally adds more detail to title. Supports markdown.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]
            Any additional metadata that you've configured your alert source to parse

        source_url : typing.Optional[str]
            If applicable, a link to the alert in the upstream system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AlertEventsCreateHttpResultV2]
            Accepted response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/alert_events/http/{jsonable_encoder(alert_source_config_id)}",
            method="POST",
            params={
                "token": token,
            },
            json={
                "deduplication_key": deduplication_key,
                "description": description,
                "metadata": metadata,
                "source_url": source_url,
                "status": status,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AlertEventsCreateHttpResultV2,
                    parse_obj_as(
                        type_=AlertEventsCreateHttpResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

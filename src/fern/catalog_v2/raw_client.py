# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.catalog_create_entry_result_v2 import CatalogCreateEntryResultV2
from ..types.catalog_create_type_result_v2 import CatalogCreateTypeResultV2
from ..types.catalog_list_entries_result_v2 import CatalogListEntriesResultV2
from ..types.catalog_list_resources_result_v2 import CatalogListResourcesResultV2
from ..types.catalog_list_types_result_v2 import CatalogListTypesResultV2
from ..types.catalog_show_entry_result_v2 import CatalogShowEntryResultV2
from ..types.catalog_show_type_result_v2 import CatalogShowTypeResultV2
from ..types.catalog_type_attribute_payload_v2 import CatalogTypeAttributePayloadV2
from ..types.catalog_update_entry_result_v2 import CatalogUpdateEntryResultV2
from ..types.catalog_update_type_result_v2 import CatalogUpdateTypeResultV2
from ..types.catalog_update_type_schema_result_v2 import CatalogUpdateTypeSchemaResultV2
from ..types.engine_param_binding_payload_v2 import EngineParamBindingPayloadV2
from .types.catalog_create_type_payload_v2categories_item import CatalogCreateTypePayloadV2CategoriesItem
from .types.catalog_create_type_payload_v2color import CatalogCreateTypePayloadV2Color
from .types.catalog_create_type_payload_v2icon import CatalogCreateTypePayloadV2Icon
from .types.catalog_update_type_payload_v2categories_item import CatalogUpdateTypePayloadV2CategoriesItem
from .types.catalog_update_type_payload_v2color import CatalogUpdateTypePayloadV2Color
from .types.catalog_update_type_payload_v2icon import CatalogUpdateTypePayloadV2Icon

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCatalogV2Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def listentries(
        self,
        *,
        catalog_type_id: str,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogListEntriesResultV2]:
        """
        List entries for a catalog type.

        Parameters
        ----------
        catalog_type_id : str
            ID of this catalog type

        page_size : typing.Optional[int]
            Integer number of records to return

        after : typing.Optional[str]
            An record's ID. This endpoint will return a list of records after this ID in relation to the API response order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListEntriesResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog_entries",
            method="GET",
            params={
                "catalog_type_id": catalog_type_id,
                "page_size": page_size,
                "after": after,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListEntriesResultV2,
                    parse_obj_as(
                        type_=CatalogListEntriesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def createentry(
        self,
        *,
        attribute_values: typing.Dict[str, EngineParamBindingPayloadV2],
        catalog_type_id: str,
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogCreateEntryResultV2]:
        """
        Create an entry within the catalog. We support a maximum of 50,000 entries per type.

        If you call this API with a payload where the external_id and catalog_type_id match an existing entry, the existing entry will be updated.

        Parameters
        ----------
        attribute_values : typing.Dict[str, EngineParamBindingPayloadV2]
            Values of this entry

        catalog_type_id : str
            ID of this catalog type

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogCreateEntryResultV2]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog_entries",
            method="POST",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, EngineParamBindingPayloadV2],
                    direction="write",
                ),
                "catalog_type_id": catalog_type_id,
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateEntryResultV2,
                    parse_obj_as(
                        type_=CatalogCreateEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogShowEntryResultV2]:
        """
        Show a single catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogShowEntryResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowEntryResultV2,
                    parse_obj_as(
                        type_=CatalogShowEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updateentry(
        self,
        id: str,
        *,
        attribute_values: typing.Dict[str, EngineParamBindingPayloadV2],
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateEntryResultV2]:
        """
        Updates an existing catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        attribute_values : typing.Dict[str, EngineParamBindingPayloadV2]
            Values of this entry

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateEntryResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, EngineParamBindingPayloadV2],
                    direction="write",
                ),
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateEntryResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroyentry(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Archives a catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def listresources(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogListResourcesResultV2]:
        """
        List available engine resources for the catalog.

        A resource represents a type of data that can be held within the catalog, so this
        endpoint can be used to see what attribute types can be used when updating the
        schema of a catalog type.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListResourcesResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog_resources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListResourcesResultV2,
                    parse_obj_as(
                        type_=CatalogListResourcesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def listtypes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogListTypesResultV2]:
        """
        List all catalog types for an organisation, including those synced from external resources.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogListTypesResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog_types",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListTypesResultV2,
                    parse_obj_as(
                        type_=CatalogListTypesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def createtype(
        self,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogCreateTypePayloadV2CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogCreateTypePayloadV2Color] = OMIT,
        icon: typing.Optional[CatalogCreateTypePayloadV2Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        type_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogCreateTypeResultV2]:
        """
        Create a catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogCreateTypePayloadV2CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogCreateTypePayloadV2Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogCreateTypePayloadV2Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        type_name : typing.Optional[str]
            The type name of this catalog type, to be used when defining attributes. This is immutable once a CatalogType has been created. For non-externally sync types, it must follow the pattern Custom["SomeName"]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogCreateTypeResultV2]
            Created response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog_types",
            method="POST",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "type_name": type_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateTypeResultV2,
                    parse_obj_as(
                        type_=CatalogCreateTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def showtype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CatalogShowTypeResultV2]:
        """
        Show a single catalog type.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogShowTypeResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowTypeResultV2,
                    parse_obj_as(
                        type_=CatalogShowTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updatetype(
        self,
        id: str,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV2CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogUpdateTypePayloadV2Color] = OMIT,
        icon: typing.Optional[CatalogUpdateTypePayloadV2Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateTypeResultV2]:
        """
        Updates an existing catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        id : str
            ID of this catalog type

        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV2CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogUpdateTypePayloadV2Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogUpdateTypePayloadV2Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateTypeResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def destroytype(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Archives a catalog type and associated entries.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def updatetypeschema(
        self,
        id: str,
        *,
        attributes: typing.Sequence[CatalogTypeAttributePayloadV2],
        version: int,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CatalogUpdateTypeSchemaResultV2]:
        """
        Update an existing catalog types schema, adding or removing attributes.

        Updating the schema is handled separately from creating and updating types, so that you don't
        have to worry about dependencies between types. For example, if type A has an attribute that
        relies on type B, you would have to create type B first.

        By allowing the creation of types without a schema, they can be created in any order, but it
        means that you need to make a separate call to this endpoint to update the schema.

        Parameters
        ----------
        id : str
            ID of this catalog type

        attributes : typing.Sequence[CatalogTypeAttributePayloadV2]

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogUpdateTypeSchemaResultV2]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}/actions/update_schema",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CatalogTypeAttributePayloadV2], direction="write"
                ),
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeSchemaResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateTypeSchemaResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCatalogV2Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def listentries(
        self,
        *,
        catalog_type_id: str,
        page_size: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogListEntriesResultV2]:
        """
        List entries for a catalog type.

        Parameters
        ----------
        catalog_type_id : str
            ID of this catalog type

        page_size : typing.Optional[int]
            Integer number of records to return

        after : typing.Optional[str]
            An record's ID. This endpoint will return a list of records after this ID in relation to the API response order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListEntriesResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog_entries",
            method="GET",
            params={
                "catalog_type_id": catalog_type_id,
                "page_size": page_size,
                "after": after,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListEntriesResultV2,
                    parse_obj_as(
                        type_=CatalogListEntriesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def createentry(
        self,
        *,
        attribute_values: typing.Dict[str, EngineParamBindingPayloadV2],
        catalog_type_id: str,
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogCreateEntryResultV2]:
        """
        Create an entry within the catalog. We support a maximum of 50,000 entries per type.

        If you call this API with a payload where the external_id and catalog_type_id match an existing entry, the existing entry will be updated.

        Parameters
        ----------
        attribute_values : typing.Dict[str, EngineParamBindingPayloadV2]
            Values of this entry

        catalog_type_id : str
            ID of this catalog type

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogCreateEntryResultV2]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog_entries",
            method="POST",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, EngineParamBindingPayloadV2],
                    direction="write",
                ),
                "catalog_type_id": catalog_type_id,
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateEntryResultV2,
                    parse_obj_as(
                        type_=CatalogCreateEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogShowEntryResultV2]:
        """
        Show a single catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogShowEntryResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowEntryResultV2,
                    parse_obj_as(
                        type_=CatalogShowEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updateentry(
        self,
        id: str,
        *,
        attribute_values: typing.Dict[str, EngineParamBindingPayloadV2],
        name: str,
        aliases: typing.Optional[typing.Sequence[str]] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        rank: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateEntryResultV2]:
        """
        Updates an existing catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        attribute_values : typing.Dict[str, EngineParamBindingPayloadV2]
            Values of this entry

        name : str
            Name is the human readable name of this entry

        aliases : typing.Optional[typing.Sequence[str]]
            Optional aliases that can be used to reference this entry

        external_id : typing.Optional[str]
            An optional alternative ID for this entry, which is ensured to be unique for the type

        rank : typing.Optional[int]
            When catalog type is ranked, this is used to help order things

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateEntryResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "aliases": aliases,
                "attribute_values": convert_and_respect_annotation_metadata(
                    object_=attribute_values,
                    annotation=typing.Dict[str, EngineParamBindingPayloadV2],
                    direction="write",
                ),
                "external_id": external_id,
                "name": name,
                "rank": rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateEntryResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateEntryResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroyentry(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives a catalog entry.

        Parameters
        ----------
        id : str
            ID of this catalog entry

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_entries/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def listresources(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogListResourcesResultV2]:
        """
        List available engine resources for the catalog.

        A resource represents a type of data that can be held within the catalog, so this
        endpoint can be used to see what attribute types can be used when updating the
        schema of a catalog type.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListResourcesResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog_resources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListResourcesResultV2,
                    parse_obj_as(
                        type_=CatalogListResourcesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def listtypes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogListTypesResultV2]:
        """
        List all catalog types for an organisation, including those synced from external resources.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogListTypesResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog_types",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogListTypesResultV2,
                    parse_obj_as(
                        type_=CatalogListTypesResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def createtype(
        self,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogCreateTypePayloadV2CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogCreateTypePayloadV2Color] = OMIT,
        icon: typing.Optional[CatalogCreateTypePayloadV2Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        type_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogCreateTypeResultV2]:
        """
        Create a catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogCreateTypePayloadV2CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogCreateTypePayloadV2Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogCreateTypePayloadV2Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        type_name : typing.Optional[str]
            The type name of this catalog type, to be used when defining attributes. This is immutable once a CatalogType has been created. For non-externally sync types, it must follow the pattern Custom["SomeName"]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogCreateTypeResultV2]
            Created response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog_types",
            method="POST",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
                "type_name": type_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogCreateTypeResultV2,
                    parse_obj_as(
                        type_=CatalogCreateTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def showtype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogShowTypeResultV2]:
        """
        Show a single catalog type.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogShowTypeResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogShowTypeResultV2,
                    parse_obj_as(
                        type_=CatalogShowTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updatetype(
        self,
        id: str,
        *,
        description: str,
        name: str,
        annotations: typing.Optional[typing.Dict[str, str]] = OMIT,
        categories: typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV2CategoriesItem]] = OMIT,
        color: typing.Optional[CatalogUpdateTypePayloadV2Color] = OMIT,
        icon: typing.Optional[CatalogUpdateTypePayloadV2Icon] = OMIT,
        ranked: typing.Optional[bool] = OMIT,
        source_repo_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateTypeResultV2]:
        """
        Updates an existing catalog type. The schema must be updated using the UpdateTypeSchema endpoint.

        Parameters
        ----------
        id : str
            ID of this catalog type

        description : str
            Human readble description of this type

        name : str
            Name is the human readable name of this type

        annotations : typing.Optional[typing.Dict[str, str]]
            Annotations that can track metadata about this type

        categories : typing.Optional[typing.Sequence[CatalogUpdateTypePayloadV2CategoriesItem]]
            What categories is this type considered part of

        color : typing.Optional[CatalogUpdateTypePayloadV2Color]
            Sets the display color of this type in the dashboard

        icon : typing.Optional[CatalogUpdateTypePayloadV2Icon]
            Sets the display icon of this type in the dashboard

        ranked : typing.Optional[bool]
            If this type should be ranked

        source_repo_url : typing.Optional[str]
            The url of the external repository where this type is managed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateTypeResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "annotations": annotations,
                "categories": categories,
                "color": color,
                "description": description,
                "icon": icon,
                "name": name,
                "ranked": ranked,
                "source_repo_url": source_repo_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateTypeResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def destroytype(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Archives a catalog type and associated entries.

        Parameters
        ----------
        id : str
            ID of this catalog type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def updatetypeschema(
        self,
        id: str,
        *,
        attributes: typing.Sequence[CatalogTypeAttributePayloadV2],
        version: int,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CatalogUpdateTypeSchemaResultV2]:
        """
        Update an existing catalog types schema, adding or removing attributes.

        Updating the schema is handled separately from creating and updating types, so that you don't
        have to worry about dependencies between types. For example, if type A has an attribute that
        relies on type B, you would have to create type B first.

        By allowing the creation of types without a schema, they can be created in any order, but it
        means that you need to make a separate call to this endpoint to update the schema.

        Parameters
        ----------
        id : str
            ID of this catalog type

        attributes : typing.Sequence[CatalogTypeAttributePayloadV2]

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogUpdateTypeSchemaResultV2]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/catalog_types/{jsonable_encoder(id)}/actions/update_schema",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CatalogTypeAttributePayloadV2], direction="write"
                ),
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogUpdateTypeSchemaResultV2,
                    parse_obj_as(
                        type_=CatalogUpdateTypeSchemaResultV2,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
